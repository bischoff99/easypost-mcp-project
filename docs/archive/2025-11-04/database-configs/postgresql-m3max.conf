# PostgreSQL Configuration Optimized for M3 Max (128GB RAM, 16 cores)
# Place this in /usr/local/var/postgres/postgresql.conf or equivalent
# Then restart PostgreSQL: brew services restart postgresql

# =============================================================================
# M3 MAX MEMORY OPTIMIZATION (128GB RAM - ACTUAL)
# =============================================================================

# Memory Configuration
shared_buffers = 32GB              # 25% of RAM (32GB)
effective_cache_size = 96GB        # 75% of RAM (96GB)
work_mem = 512MB                   # Per operation memory (2x more)
maintenance_work_mem = 4GB         # Maintenance operations (2x more)

# WAL Configuration
wal_buffers = 64MB                 # WAL buffer size
checkpoint_completion_target = 0.9 # Spread checkpoint I/O

# =============================================================================
# M3 MAX PARALLELISM (16 cores - ACTUAL)
# =============================================================================

# Parallel Query Configuration
max_worker_processes = 16          # Match CPU cores
max_parallel_workers_per_gather = 8 # Half of cores for gather operations
max_parallel_workers = 16          # Total parallel workers
max_parallel_maintenance_workers = 6 # More maintenance workers

# Background Workers
autovacuum_max_workers = 4         # Autovacuum workers
autovacuum_work_mem = 1GB          # Autovacuum memory

# =============================================================================
# M3 MAX I/O OPTIMIZATION
# =============================================================================

# I/O Configuration
effective_io_concurrency = 200     # SSD concurrency
random_page_cost = 1.1             # SSD random page cost
maintenance_io_concurrency = 100   # Maintenance I/O

# =============================================================================
# CONNECTION & RESOURCE LIMITS
# =============================================================================

# Connection Configuration
max_connections = 200              # Maximum connections
shared_preload_libraries = 'pg_stat_statements'  # Query statistics

# Logging Configuration
log_line_prefix = '%t [%p]: [%l-1] user=%u,db=%d,app=%a,client=%h '
log_statement = 'ddl'              # Log DDL statements
log_temp_files = '1GB'             # Log temp file usage

# =============================================================================
# PERFORMANCE MONITORING
# =============================================================================

# Statistics Collection
track_activities = on
track_counts = on
track_io_timing = on
track_wal_io_timing = on

# Query Planning
default_statistics_target = 1000   # Statistics target
geqo_threshold = 12               # GEQO threshold

# =============================================================================
# M3 MAX SPECIFIC TUNING
# =============================================================================

# Apple Silicon optimizations
# Use direct I/O for better performance on Apple SSDs
# These settings are automatically optimized for M3 Max architecture

# Temp file limits (prevent runaway queries)
temp_file_limit = 10GB

# Statement timeout (prevent long-running queries)
statement_timeout = '30min'

# Idle session timeout
idle_in_transaction_session_timeout = '1hour'

# =============================================================================
# DEVELOPMENT OPTIMIZATIONS
# =============================================================================

# For development environment
# fsync = off                    # ⚠️  DANGEROUS - only for development
# synchronous_commit = off      # ⚠️  DANGEROUS - only for development
# full_page_writes = off        # ⚠️  DANGEROUS - only for development

# =============================================================================
# MONITORING QUERIES
# =============================================================================

# Useful queries to monitor M3 Max performance:
#
# -- Current activity
# SELECT * FROM pg_stat_activity;
#
# -- Cache hit ratio
# SELECT
#   sum(blks_hit) / (sum(blks_hit) + sum(blks_read)) as cache_hit_ratio
# FROM pg_stat_database;
#
# -- Active connections
# SELECT count(*) as active_connections FROM pg_stat_activity
# WHERE state = 'active';
#
# -- Long running queries
# SELECT now() - query_start as duration, query
# FROM pg_stat_activity
# WHERE state = 'active'
# ORDER BY duration DESC
# LIMIT 10;
