{
  "FastMCP Tool": {
    "prefix": "mcp-tool",
    "scope": "python",
    "body": [
      "@mcp.tool()",
      "async def ${1:tool_name}(",
      "    ${2:param}: ${3:dict},",
      "    ctx: Context = None",
      ") -> dict:",
      "    \"\"\"${4:Tool description}.",
      "    ",
      "    Args:",
      "        ${2:param}: ${5:Parameter description}",
      "        ctx: FastMCP context for logging",
      "    ",
      "    Returns:",
      "        Standardized response with status, data, message, timestamp",
      "    \"\"\"",
      "    try:",
      "        if ctx:",
      "            ctx.info(f\"${6:Processing...}\")",
      "        ",
      "        # TODO: Implement logic",
      "        $0",
      "        ",
      "        return {",
      "            \"status\": \"success\",",
      "            \"data\": {},",
      "            \"message\": \"${7:Success message}\",",
      "            \"timestamp\": datetime.now(timezone.utc).isoformat(),",
      "        }",
      "    except Exception as e:",
      "        logger.error(f\"Error in ${1:tool_name}: {str(e)}\")",
      "        return {",
      "            \"status\": \"error\",",
      "            \"data\": None,",
      "            \"message\": f\"Error: {str(e)}\",",
      "            \"timestamp\": datetime.now(timezone.utc).isoformat(),",
      "        }"
    ],
    "description": "Create FastMCP tool with standardized response"
  },
  "FastAPI Endpoint": {
    "prefix": "fastapi-endpoint",
    "scope": "python",
    "body": [
      "@app.${1|post,get,put,delete|}(\"${2:/api/endpoint}\", status_code=status.HTTP_${3|200,201,204|}_${4|OK,CREATED,NO_CONTENT|})",
      "@limiter.limit(\"${5:10}/minute\")",
      "async def ${6:endpoint_name}(",
      "    request: Request,",
      "    ${7:data}: ${8:RequestModel}",
      ") -> Dict[str, Any]:",
      "    \"\"\"${9:Endpoint description}.",
      "    ",
      "    Args:",
      "        request: FastAPI request object",
      "        ${7:data}: ${10:Request data description}",
      "    ",
      "    Returns:",
      "        Standardized API response",
      "    ",
      "    Raises:",
      "        HTTPException: On validation or processing errors",
      "    \"\"\"",
      "    try:",
      "        logger.info(f\"[{request.state.request_id}] ${11:Processing request}\")",
      "        ",
      "        # TODO: Implement logic",
      "        $0",
      "        ",
      "        return {",
      "            \"status\": \"success\",",
      "            \"data\": {},",
      "            \"message\": \"${12:Success message}\",",
      "            \"timestamp\": datetime.now(timezone.utc).isoformat(),",
      "        }",
      "    except ValidationError as e:",
      "        logger.error(f\"[{request.state.request_id}] Validation error: {str(e)}\")",
      "        raise HTTPException(",
      "            status_code=status.HTTP_400_BAD_REQUEST,",
      "            detail={",
      "                \"status\": \"error\",",
      "                \"data\": None,",
      "                \"message\": f\"Validation error: {str(e)}\",",
      "                \"timestamp\": datetime.now(timezone.utc).isoformat(),",
      "            },",
      "        ) from e",
      "    except Exception as e:",
      "        logger.error(f\"[{request.state.request_id}] Error: {str(e)}\")",
      "        raise HTTPException(",
      "            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,",
      "            detail={",
      "                \"status\": \"error\",",
      "                \"data\": None,",
      "                \"message\": \"Internal server error\",",
      "                \"timestamp\": datetime.now(timezone.utc).isoformat(),",
      "            },",
      "        ) from e"
    ],
    "description": "Create FastAPI endpoint with rate limiting and error handling"
  },
  "React Functional Component": {
    "prefix": "rfc-full",
    "scope": "javascript,javascriptreact",
    "body": [
      "import { useState, useEffect } from 'react';",
      "import './${1:${TM_FILENAME_BASE}}.css';",
      "",
      "/**",
      " * ${2:Component description}",
      " * ",
      " * @param {Object} props - Component props",
      " * @returns {JSX.Element}",
      " */",
      "export default function ${1:${TM_FILENAME_BASE}}({ ${3:props} }) {",
      "  const [${4:data}, set${4/(.*)/${1:/capitalize}/}] = useState(${5:null});",
      "  const [loading, setLoading] = useState(false);",
      "  const [error, setError] = useState('');",
      "",
      "  useEffect(() => {",
      "    // TODO: Implement effect",
      "    $0",
      "  }, []);",
      "",
      "  const handle${6:Action} = async () => {",
      "    setLoading(true);",
      "    setError('');",
      "    ",
      "    try {",
      "      // TODO: Implement action",
      "    } catch (err) {",
      "      console.error('Error:', err);",
      "      setError(err.message || 'An error occurred');",
      "    } finally {",
      "      setLoading(false);",
      "    }",
      "  };",
      "",
      "  if (loading) return <div className=\"loading\">Loading...</div>;",
      "  if (error) return <div className=\"error\">{error}</div>;",
      "",
      "  return (",
      "    <div className=\"${1/(.*)/\\L$1/}\">",
      "      <h2>${7:Component Title}</h2>",
      "      {/* TODO: Add component content */}",
      "    </div>",
      "  );",
      "}"
    ],
    "description": "Full React functional component with state, effects, and error handling"
  },
  "Pytest Test Function": {
    "prefix": "pytest-func",
    "scope": "python",
    "body": [
      "@pytest.mark.asyncio",
      "async def test_${1:function_name}(${2:fixtures}):",
      "    \"\"\"${3:Test description}.",
      "    ",
      "    Args:",
      "        ${2:fixtures}: ${4:Fixture description}",
      "    \"\"\"",
      "    # Arrange",
      "    ${5:# Setup test data}",
      "    $0",
      "    ",
      "    # Act",
      "    ${6:# Execute action}",
      "    ",
      "    # Assert",
      "    ${7:# Verify results}",
      "    assert ${8:condition}, \"${9:Error message}\""
    ],
    "description": "Pytest async test function with AAA pattern"
  },
  "Quick Log": {
    "prefix": "log",
    "scope": "python,javascript,javascriptreact",
    "body": [
      "logger.info(f\"ðŸ” ${1:label}: {${2:variable}}\")"
    ],
    "description": "Quick debug log"
  },
  "Console Debug": {
    "prefix": "cl",
    "scope": "javascript,javascriptreact",
    "body": [
      "console.log('ðŸ” ${1:label}:', ${2:variable})$0"
    ],
    "description": "Quick console log with emoji"
  },
  "Try-Catch": {
    "prefix": "try",
    "scope": "javascript,javascriptreact",
    "body": [
      "try {",
      "  $0",
      "} catch (error) {",
      "  console.error('Error:', error);",
      "  toast.error('Error', { description: error.message });",
      "}"
    ],
    "description": "Try-catch with toast notification"
  },
  "Async Try": {
    "prefix": "atry",
    "scope": "python",
    "body": [
      "try:",
      "    $0",
      "except ${1:Exception} as e:",
      "    logger.error(f\"Error: {str(e)}\")",
      "    raise"
    ],
    "description": "Async try-except with logging"
  },
  "API Call": {
    "prefix": "api",
    "scope": "javascript,javascriptreact",
    "body": [
      "const ${1:fetch}${2:Data} = async () => {",
      "  setLoading(true);",
      "  try {",
      "    const result = await api.${3|get,post,put,delete|}('${4:/endpoint}');",
      "    ${5:setData}(result.data);",
      "  } catch (err) {",
      "    toast.error('Error', { description: err.message });",
      "  } finally {",
      "    setLoading(false);",
      "  }",
      "}$0"
    ],
    "description": "Async API call with error handling"
  },
  "UseState Hook": {
    "prefix": "us",
    "scope": "javascript,javascriptreact",
    "body": [
      "const [${1:state}, set${1/(.*)/${1:/capitalize}/}] = useState(${2:initialValue})$0"
    ],
    "description": "Quick useState hook"
  },
  "UseEffect Hook": {
    "prefix": "ue",
    "scope": "javascript,javascriptreact",
    "body": [
      "useEffect(() => {",
      "  $0",
      "  ",
      "  return () => {",
      "    // Cleanup",
      "  };",
      "}, [${1:dependencies}])"
    ],
    "description": "Quick useEffect with cleanup"
  },
  "MCP Resource": {
    "prefix": "mcp-resource",
    "scope": "python",
    "body": [
      "@mcp.resource(\"${1:resource}://${2:path}\")",
      "async def ${3:resource_name}(uri: str) -> str:",
      "    \"\"\"${4:Resource description}.",
      "    ",
      "    Args:",
      "        uri: Resource URI",
      "    Returns:",
      "        Resource content as string",
      "    \"\"\"",
      "    try:",
      "        $0",
      "        return json.dumps(data, indent=2)",
      "    except Exception as e:",
      "        logger.error(f\"Error in ${3:resource_name}: {str(e)}\")",
      "        return json.dumps({\"error\": str(e)})"
    ],
    "description": "MCP resource pattern"
  },
  "Bulk Operation": {
    "prefix": "bulk-op",
    "scope": "python",
    "body": [
      "async def ${1:process}_batch(",
      "    items: List[${2:Item}],",
      "    workers: int = ${3:16},",
      ") -> List[Dict]:",
      "    \"\"\"${4:Process items in parallel}.",
      "    ",
      "    Args:",
      "        items: Items to process",
      "        workers: Number of parallel workers (M3 Max optimized)",
      "    Returns:",
      "        List of results",
      "    \"\"\"",
      "    async def process_one(item: ${2:Item}) -> Dict:",
      "        try:",
      "            $0",
      "            return {\"status\": \"success\", \"data\": result}",
      "        except Exception as e:",
      "            logger.error(f\"Error processing item: {str(e)}\")",
      "            return {\"status\": \"error\", \"message\": str(e)}",
      "    ",
      "    results = await asyncio.gather(*[",
      "        process_one(item) for item in items",
      "    ])",
      "    return results"
    ],
    "description": "Bulk operation with parallel processing"
  },
  "MCP Prompt": {
    "prefix": "mcp-prompt",
    "scope": "python",
    "body": [
      "@mcp.prompt(\"${1:prompt-name}\")",
      "async def ${2:prompt_function}() -> str:",
      "    \"\"\"${3:Prompt description}.",
      "    ",
      "    Returns:",
      "        Prompt content as string",
      "    \"\"\"",
      "    return \"\"\"",
      "${4:Prompt content here}",
      "",
      "Context:",
      "- ${5:Context item 1}",
      "- ${6:Context item 2}",
      "",
      "Instructions:",
      "1. ${7:Step 1}",
      "2. ${8:Step 2}",
      "",
      "Output format:",
      "${9:Expected output format}",
      "\"\"\"$0"
    ],
    "description": "MCP prompt template"
  }
}
